import unittest
import logging
from mflod.crypto.key_manager import KeyManager
from unittest_data_provider import data_provider
from cryptography.hazmat.backends.openssl import rsa


logger = logging.getLogger()
logger.setLevel(logging.DEBUG)


class TestKeyManager(unittest.TestCase):
    """
    Running KeyManager class unit tests

    Developers:
        - (tnanoba) Tornike Nanobashvili
    """

    def setUp(self):
        # Instantiate KeyManager class
        self.manager = KeyManager()

    def tearDown(self):
        # Tears down manager property to None
        self.manager = None

    def test_generate_plain_rsa_key(self):
        """ Unit tests generate_plain_rsa_key method from KeyManager class

        Asserts that the generated key is instance of _RSAPrivateKey object on success
        Asserts that the exception takes place when invalid key_size is specified

        @developer: tnanoba

        :return: void
        """
        # On successful call
        self.assertIsInstance(self.manager.generate_plain_rsa_key(2048), rsa._RSAPrivateKey)

        # On failure call, which arises below written ValueError exception
        self.manager.generate_plain_rsa_key(1)

        # Fires up ValueError exception
        self.assertRaises(ValueError)

    def test_generate_pgp_key(self):
        """ Unit tests GnuPGWrapper class generate_pgp_key method

        Asserts that the pgp key pair is being generated and returned fingerprint is valid hexadecimal

        @developer: tnanoba

        :return: void
        """
        # Generates RSA 512 bits key
        pgp_fingerprint = self.manager.generate_pgp_key(512, 'Unit Test Key', 'Generated by Unit Testing')

        # Asserts that the pgp key fingerprint is hexadecimal
        self.assertTrue(int(pgp_fingerprint, 16))

        # Test case for many pgp keys
        self.test_get_pgp_rsa_keys()

        # Test case for one pgp key with pgp_fingerprint for private key testing
        self.test_get_pgp_rsa_key_id(pgp_fingerprint, True)

        # Test case for one pgp key with pgp_fingerprint for public key testing
        self.test_get_pgp_rsa_key_id(pgp_fingerprint, False)

        # Test case for deleting pgp key pair
        self.test_delete_pgp_key(pgp_fingerprint)

    @data_provider(lambda: (
        [10],
        [1],
        [0],
        ['NaN'],
    ))
    def test_get_pgp_rsa_keys(self, limit):
        """ Unit tests KeyManager class get_pgp_rsa_keys method

        Asserts that retrieved pgp keys are returned as a _RSAPrivateKey instances

        @developer: tnanoba

        :return: void
        """
        for response in self.manager.get_pgp_rsa_keys(limit):
            self.assertIsInstance(response, rsa._RSAPrivateKey)

    def test_get_pgp_rsa_key_id(self, pgp_fingerprint=None, secret=True):
        """ Unit tests KeyManager class get_pgp_rsa_key_id method

        Asserts that in case of provided pgp_fingerprint method returns _RSAPrivateKey instance,
            otherwise None.

        @developer: tnanoba

        :param pgp_fingerprint: hex
        :return: void
        """
        if pgp_fingerprint is None:
            self.assertEqual(
                self.manager.get_pgp_rsa_key_id(None),
                None
            )
        else:
            if secret:
                self.assertIsInstance(
                    self.manager.get_pgp_rsa_key_id(pgp_fingerprint, True),
                    rsa._RSAPrivateKey
                )
            else:
                self.assertIsInstance(
                    self.manager.get_pgp_rsa_key_id(pgp_fingerprint, False),
                    rsa._RSAPublicKey
                )

    def test_delete_pgp_key(self, pgp_fingerprint=None):
        """ Unit tests GnuPGWrapper class delete_pgp_key method

        Asserts that the pgp key pair is being successfully deleted when pgp_fingerprint is specified,
            otherwise expects and arises TypeError when fingerprint equals to default value, None.

        @developer: tnanoba

        :param pgp_fingerprint: hex
        :return: void
        """
        self.manager.delete_pgp_key(pgp_fingerprint)

        if pgp_fingerprint is None:
            self.assertRaises(TypeError)
        else:
            pass

    @data_provider(lambda: (
            # First RSA example
            (
                29,
                19,
                3,
                551,
                143,
                '-----BEGIN RSA PRIVATE KEY-----\nMB0CAQACAgInAgEDAgIAjwIBHQIBEwIBAwIBEQIBGg==\
\n-----END RSA PRIVATE KEY-----\n',
                'RSA Private Key with primes (p=29, q=19, e=3, n=551, d=143)'
            ),
            # Second RSA example
            (
                17,
                11,
                7,
                187,
                23,
                '-----BEGIN RSA PRIVATE KEY-----\nMBwCAQACAgC7AgEHAgEXAgERAgELAgEHAgEDAgEO\
\n-----END RSA PRIVATE KEY-----\n',
                'RSA Private Key with primes (p=17, q=11, e=7, n=187, d=23)'
            ),
            # Third RSA (real world 2048 bits) example
            (
                    int("""
138133887206382176761507485023149045324394406356618093031581076741922489034876137480615698485460627207814398596044271347
156137733880754302229221017426814229753391639946775871049788781802676830374806138655326051679825558512869931144188005229
036742559169321863885557827540941784013802519277422580899637213142801""".replace('\n', '')),
                    int("""
160610720457038277366344592358817340130479244732791320106452900714588738028435304462639953024062552373041656149506702613
311786935810507268294353635529609659867619257779458831980339907950713231024179217233853876064093620174836760274020940731
994161078262118004579680703628039654811143411985851851791532744095603""".replace('\n', '')),
                    65537,
                    int("""
221857831437483038595548415251069380454909938275840439234632812305124532748382787277205127935982657784675468183182377654
070281133955482564402941653003705886572093833559616210443817618135846775067628792529922820421803832668464539390332794476
036238295062652169902837425388388502324639957972106310750774137748397437758201796465713746929380640096065381632127425792
052342125795972713023981307612822359650584659004308837316691011712195842919667633926022030657345198697078392115040088544
547749063830252854026045344845412767253366450256676941025513364566457715988404949463215255053945035859869799970541560998
33155864035204003""".replace('\n', '')),
                    int("""
774258566615443626919834318143548709884678141853547957036194842420623455174445221733546437042050041141925286448319719788
518055449916608742975105234236603211780837205939294662028195058689042142670824602867624615267816652097120424099754575937
929540596188609927109021872785565257640985027096961742332034701090279038719424040798854027488622558450755364609952053672
116351218795432733961527395515227598768207630697735451756061154658149477670165252336206360926174769384631094819008133804
449378682486662037646326377192763183019680935446405255156069367505192223630090993126161166064374680913617070679055236591
468882709593873""".replace('\n', '')),
                    """-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAr77JDlG9cCP4BXv6a1xHlA8IW/ly4H0iE6gz2kPzWMvpKfEo
lbo0YD61tz5HDjAM8XL9rGIIXepnXlglErTSWgtWY75nAcuBMC1F3lMguUHM5m5K
vGW39i7n+TtCjFv6aE6EJMk/3oDfZrqV9lbAlFxplRNS0Qa3nZ0ybNO3D6ypBZFR
87n5QKuH3/7NHbSwxxZVk5XLFJbHW+Z7aGqfetSMRja1l6V4UDFkWgywY86prEJq
NTyrK+ltvOfYgHDj785nbLsVce6hDiw6n05brI2lkjZOc7pHD/R9/c2wkGAQBzdk
E4jaU7NyOQjv8ZgQbZ3wdnSQD1f4KJ6fuYYbowIDAQABAoIBAAYiII59NXZxmD50
wQdjJ+UCZfZzwlm+9DlUZZmImo2u8XBdyAlQVMibwlK7+9XXwR6MtqP/+IPH4kX4
HzRubBLpZ2FBbAMzhiAszE3sf8KyCa5sYJ5U5x0n2OpT8kgcuPn6l4EDJv/4Zmja
5SXniX6uqklMwddP+94mdh6MgEyDLrqzqvDL2K1bhXPXvPmNp6ubpgqmRiuOYuy+
xDEIGWLOPgn7K7QoVP+KUzJ9F9v1qlOUTM1UjvUsQqeJRl//Svu5CzzHL8oMhiLa
xuvEvzfj604vv1idyUqUN+l3NK64gJEa31eDmVOmlvDTDyzbNookzTKbkRmD28Zp
nYUqPxECgYEAxLWNJCagBq/5OMhJAikEpD4OEm04bYBFGUH4Gknw23AwPMsYFuqx
zffoE1n4i6gImieiR8FBp1weMxam0UjJYD6YFBXlBjGkugt2Cnz/EG29aZQF0IMw
MjsDE3bR/PEfQ5AvCcB8VUrntiD20RAAS5DTVD5GPNIHTkDgSbc2HxECgYEA5Lee
NuPdi9Q5L5TJt8iJL0KAAmvuM/q/Di1w/SIZddBeVcLhPlL0/bo+c40dJvKPY35J
kiS7WeC1QSBzcYT1suypfHSnseBGTMlDuoKkn1z7RIstNH4Ariu5YMma4p8tLc/8
TsovZ0CCKyffFMLX9ATqxS1LVC6GyUCXCa3xt3MCgYBJtTG+4w5BkzzSjxH0UkRf
+rSxKOXk+hRqQ3Lg/uXWg/I/RWawZ57aa9M1NRhR1FPs138SXhLo0DastAcsEpcK
jknT9ORNbtqnr9W6Vl4I3OYFoqaPHCk6GSys5XAH1J3/Zg6KG+s61od+klmJuvIx
XoIhZfhRn+2G3/5rANCx0QKBgBEiqJnYLIsDVV15OjuorI573vdPesMuMA4x3Vs5
qMqo18h5F0MCGBTCVVd25Q478f40QfLPCbJMIYhFlCCXI4lKLdCDNOUgtmOeWJKq
owbFgpW6D6L1JbvmzravpAkCf/IEuRR2FWMY9CejjxURG/jOPYCUSiZ+bd66FhbF
j2x9AoGASNTVo1Y5xMT7CDg2HEAgBCFIKJhZK4HclN6M1biHuoCEhS11TBKkPDGb
MyDhCHwAK3oG8gjkvgf6N39jTAXg+3G1LKWbMl5E3gywvfD045RCXPYuQ6N6hKGG
ua40aPHoDf7fywVwzRtRGJ241VlBJDHTIRZ0iAzfv0J1l30Cb3g=
-----END RSA PRIVATE KEY-----
""",
                    'RSA 2048 bits Private key example'
            )
    ))
    def test_compute_rsa_private_key(self, p, q, e, n, d, expected, message):
        """ Unit tests compute_rsa_private_key method from KeyManager class

        @developer: tnanoba

        Firstly test asserts that the aforementioned method generates correct RSA private key based on
        provided RSA semi-primes (p, q, e, n, d).

        Secondly test asserts that the rsa_private_key_to_pem method correctly converts cryptography lib instance
        into a PEM format.

        :return: void
        """
        self.assertEqual(
            KeyManager.rsa_private_key_to_pem(
                KeyManager.compute_rsa_private_key(p, q, e, n, d)
            ).decode('utf-8'),
            expected,
            message
        )

    def test_rsa_public_key_to_pem(self):
        """ Unit tests whether no exception occurs on RSA public key generation and result is instance of bytes

        @developer: tnanoba

        :return: void
        """
        rsa_public_key = self.manager.generate_plain_rsa_key(512).public_key()

        self.assertTrue(
            isinstance(KeyManager.rsa_public_key_to_pem(rsa_public_key), bytes)
        )

    def test_return_rsa_key_from_pgp_method(self):
        """ Unit tests KeyManager Class "protected" _return_rsa_key_from_pgp method

        Asserts that in case of fake data provided as a pgp_key and it is not valid bytes,
            exception arises.

        @developer: tnanoba

        :return: void
        """
        self.manager._return_rsa_key_from_pgp('bar', True)

        self.assertRaises(Exception)

if __name__ == '__main__':
    unittest.main()
